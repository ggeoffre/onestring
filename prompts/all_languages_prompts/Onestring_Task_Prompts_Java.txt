# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright (C) 2025-2026 ggeoffre, LLC
===============================================================================
JAVA - FIRST FRAMEWORK (SPRING)
===============================================================================

TASK 1 - JAVA DATA (MONGO)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. Create a java method to connect to a mongo database
  2. Create a java method that will store the following string into a mongo database
  3. Create a java method that will retrieve the following string from a mongo database
  4. Create a java method that will delete the following string from a mongo database
  5. Create a main method that will call each of the methods
  6. Create a gradle.build file to include all requirements in this source file
  7. Modify all five methods into one source file using this string as the string that is being stored:

  A. Create a java method that will update any value in the key value pair of a mutable map
  B. Create a java method that will generate a random number between 22.4 and 34.1, limited to one decimal place of precision
  C. Create a java method that will generate the integer value of the current Unix Epoch Timestamp
  D. Create a java method that will update both the "recorded" value with the current Unix Epoch Timestamp, and the "value" with a random number between 22.4 and 34.1, using the following string as input:
  E. Modify the original code to pass-in/insert a randomized string into the mongo database each time the code is run
  F. Create a java method that will remove any key/value pair from a map (like "id" or "_id")
  G. Combine all of the above to create a small helper file that works with the OneString JSON data (generate sample data, validate required fields, and convert JSON to CSV). This helper should be simple utility code and can be called directly.


TASK 2 - JAVA API (MONGO)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. create a very basic web app using the java language spring framework
  2. what would the gradle.build file look like for this Main.java file
  3. how do i modify the spring app to bind to any ip address and a specific port when it runs
  4. add routes for the following:
      GET /
      POST /echo
      POST /log
      GET /report
      POST or GET /purge
  A. return the exact same JSON object that is sent in on the HTTP POST request
  B. create a static string constant for the following JSON structure:
        { "recorded" : 1768570200, "location" : "den", "sensor" : "bmp280", "measurement" : "temperature", "units" : "C", "value" : 22.3 }
  C. create a method to convert a json string to a csv string, using the keys as the column names
  D. can you do this without using the crate csv
  E. return the csv string as a downloadable file, be sure to modify the headers of the response
  F. return string message as a JSON object
  G. use the WGET/CURL test script you created above to generate a postman file for importing the API endpoints


TASK 3 - JAVA ACCESS (MONGO)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. write a Java interface for sensor data access with three abstract methods: log, fetch, and purge, using JSON strings and type declarations.
  2. create a class that implements the sensor data access protocol interface for MongoDataAccess.java
  3. in a Main.java file, create an instance of the MongoDataAccess class and call the log, fetch, and purge methods
  4. what would the gradle.build file look like for this Main.java file


TASK 4 - JAVA LEGOS (MONGO)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  I. copy the entire api solution from the previous exercise ./java/api/spring-app into ./java/legos
  II. copy only the MongoDataAccess.java, SensorDataAccessProtocol.java from the previous exercise ./java/access into ./java/legos
  III. copy only the SensorDataHelper.java from the previous exercise ./java/data into ./java/legos
  NOTE: for III above, this code came from "EXTRA PROMPTS TO TRY:" letter "G" in task 1 "DATA"

  1. in each of the three methods of MongoDataAccess.java (logSensorData, fetchSensorData, purgeSensorData) create a connection to the mongo database, use the same/similar logic for connecting to a mongo database found in the MongoData.java source file
  2. in the MongoDataAccess.java's logSensorData, take the "String jsonData" being passed in to the logSensorData() method to populate the params of the insert, use the same/similar logic for inserting sensor data into a mongo database found in the MongoData.java source file
  3. in the MongoDataAccess.java's fetchSensorData, create a List<String> of JSON strings resulting from the select to a mongo collection as the return for fetchSensorData(), use the same/similar logic for selecting sensor data from a mongo database found in the MongoData.java source file
  4. in the MongoDataAccess.java's purgeSensorData, delete/truncate all data in the sensor data collection, use the same/similar logic for deleting/truncating sensor data from a mongo database found in the MongoData.java source file
  5. Reuse the OneString helper from earlier tasks for generating, validating, and formatting data. Treat it as a simple utility that can be called directly from the application code.

  A. Using the public interface for SensorDataAccessProtocol, implement a method to instantiate a new sensor data access object based on an environment variable.
  B. Implement a better logging mechanism for the sensor data access object.


TASK 1 - JAVA DATA (CASSANDRA)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. Create a java method to connect to a cassandra database
  2. Create a java method that will store the following string into a cassandra database
  3. Create a java method that will retrieve the following string from a cassandra database
  4. Create a java method that will delete the following string from a cassandra database
  5. Create a main method that will call each of the methods
  6. Create a gradle.build file to include all requirements in this source file
  7. Modify all five methods into one source file using this string as the string that is being stored:

  A. Create a java method that will update any value in the key value pair of a mutable map
  B. Create a java method that will generate a random number between 22.4 and 34.1, limited to one decimal place of precision
  C. Create a java method that will generate the integer value of the current Unix Epoch Timestamp
  D. Create a java method that will update both the "recorded" value with the current Unix Epoch Timestamp, and the "value" with a random number between 22.4 and 34.1, using the following string as input:
  E. Modify the original code to pass-in/insert a randomized string into the cassandra database each time the code is run
  F. Create a java method that will remove any key/value pair from a map (like "id" or "_id")
  G. Combine all of the above to create a small helper file that works with the OneString JSON data (generate sample data, validate required fields, and convert JSON to CSV). This helper should be simple utility code and can be called directly.


TASK 2 - JAVA API (CASSANDRA)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. create a very basic web app using the java language spring framework
  2. what would the gradle.build file look like for this Main.java file
  3. how do i modify the spring app to bind to any ip address and a specific port when it runs
  4. add routes for the following:
      GET /
      POST /echo
      POST /log
      GET /report
      POST or GET /purge
  A. return the exact same JSON object that is sent in on the HTTP POST request
  B. create a static string constant for the following JSON structure:
        { "recorded" : 1768570200, "location" : "den", "sensor" : "bmp280", "measurement" : "temperature", "units" : "C", "value" : 22.3 }
  C. create a method to convert a json string to a csv string, using the keys as the column names
  D. can you do this without using the crate csv
  E. return the csv string as a downloadable file, be sure to modify the headers of the response
  F. return string message as a JSON object
  G. use the WGET/CURL test script you created above to generate a postman file for importing the API endpoints


TASK 3 - JAVA ACCESS (CASSANDRA)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. write a Java interface for sensor data access with three abstract methods: log, fetch, and purge, using JSON strings and type declarations.
  2. create a class that implements the sensor data access protocol interface for CassandraDataAccess.java
  3. in a Main.java file, create an instance of the CassandraDataAccess class and call the log, fetch, and purge methods
  4. what would the gradle.build file look like for this Main.java file


TASK 4 - JAVA LEGOS (CASSANDRA)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  I. copy the entire api solution from the previous exercise ./java/api/spring-app into ./java/legos
  II. copy only the CassandraDataAccess.java, SensorDataAccessProtocol.java from the previous exercise ./java/access into ./java/legos
  III. copy only the SensorDataHelper.java from the previous exercise ./java/data into ./java/legos
  NOTE: for III above, this code came from "EXTRA PROMPTS TO TRY:" letter "G" in task 1 "DATA"

  1. in each of the three methods of CassandraDataAccess.java (logSensorData, fetchSensorData, purgeSensorData) create a connection to the cassandra database, use the same/similar logic for connecting to a cassandra database found in the CassandraData.java source file
  2. in the CassandraDataAccess.java's logSensorData, take the "String jsonData" being passed in to the logSensorData() method to populate the params of the insert, use the same/similar logic for inserting sensor data into a cassandra database found in the CassandraData.java source file
  3. in the CassandraDataAccess.java's fetchSensorData, create a List<String> of JSON strings resulting from the select to a cassandra table as the return for fetchSensorData(), use the same/similar logic for selecting sensor data from a cassandra database found in the CassandraData.java source file
  4. in the CassandraDataAccess.java's purgeSensorData, delete/truncate all data in the sensor data table, use the same/similar logic for deleting/truncating sensor data from a cassandra database found in the CassandraData.java source file
  5. Reuse the OneString helper from earlier tasks for generating, validating, and formatting data. Treat it as a simple utility that can be called directly from the application code.

  A. Using the public interface for SensorDataAccessProtocol, implement a method to instantiate a new sensor data access object based on an environment variable.
  B. Implement a better logging mechanism for the sensor data access object.


===============================================================================


TASK 1 - JAVA DATA (MYSQL)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. Create a java method to connect to a mysql database
  2. Create a java method that will store the following string into a mysql database
  3. Create a java method that will retrieve the following string from a mysql database
  4. Create a java method that will delete the following string from a mysql database
  5. Create a main method that will call each of the methods
  6. Create a gradle.build file to include all requirements in this source file
  7. Modify all five methods into one source file using this string as the string that is being stored:

  A. Create a java method that will update any value in the key value pair of a mutable map
  B. Create a java method that will generate a random number between 22.4 and 34.1, limited to one decimal place of precision
  C. Create a java method that will generate the integer value of the current Unix Epoch Timestamp
  D. Create a java method that will update both the "recorded" value with the current Unix Epoch Timestamp, and the "value" with a random number between 22.4 and 34.1, using the following string as input:
  E. Modify the original code to pass-in/insert a randomized string into the mysql database each time the code is run
  F. Create a java method that will remove any key/value pair from a map (like "id" or "_id")
  G. Combine all of the above to create a small helper file that works with the OneString JSON data (generate sample data, validate required fields, and convert JSON to CSV). This helper should be simple utility code and can be called directly.


TASK 2 - JAVA API (MYSQL)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. create a very basic web app using the java language spring framework
  2. what would the gradle.build file look like for this Main.java file
  3. how do i modify the spring app to bind to any ip address and a specific port when it runs
  4. add routes for the following:
      GET /
      POST /echo
      POST /log
      GET /report
      POST or GET /purge
  A. return the exact same JSON object that is sent in on the HTTP POST request
  B. create a static string constant for the following JSON structure:
        { "recorded" : 1768570200, "location" : "den", "sensor" : "bmp280", "measurement" : "temperature", "units" : "C", "value" : 22.3 }
  C. create a method to convert a json string to a csv string, using the keys as the column names
  D. can you do this without using the crate csv
  E. return the csv string as a downloadable file, be sure to modify the headers of the response
  F. return string message as a JSON object
  G. use the WGET/CURL test script you created above to generate a postman file for importing the API endpoints


TASK 3 - JAVA ACCESS (MYSQL)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. write a Java interface for sensor data access with three abstract methods: log, fetch, and purge, using JSON strings and type declarations.
  2. create a class that implements the sensor data access protocol interface for MysqlDataAccess.java
  3. in a Main.java file, create an instance of the MysqlDataAccess class and call the log, fetch, and purge methods
  4. what would the gradle.build file look like for this Main.java file


TASK 4 - JAVA LEGOS (MYSQL)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  I. copy the entire api solution from the previous exercise ./java/api/spring-app into ./java/legos
  II. copy only the MysqlDataAccess.java, SensorDataAccessProtocol.java from the previous exercise ./java/access into ./java/legos
  III. copy only the SensorDataHelper.java from the previous exercise ./java/data into ./java/legos
  NOTE: for III above, this code came from "EXTRA PROMPTS TO TRY:" letter "G" in task 1 "DATA"

  1. in each of the three methods of MysqlDataAccess.java (logSensorData, fetchSensorData, purgeSensorData) create a connection to the mysql database, use the same/similar logic for connecting to a mysql database found in the MysqlData.java source file
  2. in the MysqlDataAccess.java's logSensorData, take the "String jsonData" being passed in to the logSensorData() method to populate the params of the insert, use the same/similar logic for inserting sensor data into a mysql database found in the MysqlData.java source file
  3. in the MysqlDataAccess.java's fetchSensorData, create a List<String> of JSON strings resulting from the select to a mysql table as the return for fetchSensorData(), use the same/similar logic for selecting sensor data from a mysql database found in the MysqlData.java source file
  4. in the MysqlDataAccess.java's purgeSensorData, delete/truncate all data in the sensor data table, use the same/similar logic for deleting/truncating sensor data from a mysql database found in the MysqlData.java source file
  5. Reuse the OneString helper from earlier tasks for generating, validating, and formatting data. Treat it as a simple utility that can be called directly from the application code.

  A. Using the public interface for SensorDataAccessProtocol, implement a method to instantiate a new sensor data access object based on an environment variable.
  B. Implement a better logging mechanism for the sensor data access object.


===============================================================================


TASK 1 - JAVA DATA (POSTGRES)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. Create a java method to connect to a postgres database
  2. Create a java method that will store the following string into a postgres database
  3. Create a java method that will retrieve the following string from a postgres database
  4. Create a java method that will delete the following string from a postgres database
  5. Create a main method that will call each of the methods
  6. Create a gradle.build file to include all requirements in this source file
  7. Modify all five methods into one source file using this string as the string that is being stored:

  A. Create a java method that will update any value in the key value pair of a mutable map
  B. Create a java method that will generate a random number between 22.4 and 34.1, limited to one decimal place of precision
  C. Create a java method that will generate the integer value of the current Unix Epoch Timestamp
  D. Create a java method that will update both the "recorded" value with the current Unix Epoch Timestamp, and the "value" with a random number between 22.4 and 34.1, using the following string as input:
  E. Modify the original code to pass-in/insert a randomized string into the postgres database each time the code is run
  F. Create a java method that will remove any key/value pair from a map (like "id" or "_id")
  G. Combine all of the above to create a small helper file that works with the OneString JSON data (generate sample data, validate required fields, and convert JSON to CSV). This helper should be simple utility code and can be called directly.


TASK 2 - JAVA API (POSTGRES)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. create a very basic web app using the java language spring framework
  2. what would the gradle.build file look like for this Main.java file
  3. how do i modify the spring app to bind to any ip address and a specific port when it runs
  4. add routes for the following:
      GET /
      POST /echo
      POST /log
      GET /report
      POST or GET /purge
  A. return the exact same JSON object that is sent in on the HTTP POST request
  B. create a static string constant for the following JSON structure:
        { "recorded" : 1768570200, "location" : "den", "sensor" : "bmp280", "measurement" : "temperature", "units" : "C", "value" : 22.3 }
  C. create a method to convert a json string to a csv string, using the keys as the column names
  D. can you do this without using the crate csv
  E. return the csv string as a downloadable file, be sure to modify the headers of the response
  F. return string message as a JSON object
  G. use the WGET/CURL test script you created above to generate a postman file for importing the API endpoints


TASK 3 - JAVA ACCESS (POSTGRES)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. write a Java interface for sensor data access with three abstract methods: log, fetch, and purge, using JSON strings and type declarations.
  2. create a class that implements the sensor data access protocol interface for PostgresDataAccess.java
  3. in a Main.java file, create an instance of the PostgresDataAccess class and call the log, fetch, and purge methods
  4. what would the gradle.build file look like for this Main.java file


TASK 4 - JAVA LEGOS (POSTGRES)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  I. copy the entire api solution from the previous exercise ./java/api/spring-app into ./java/legos
  II. copy only the PostgresDataAccess.java, SensorDataAccessProtocol.java from the previous exercise ./java/access into ./java/legos
  III. copy only the SensorDataHelper.java from the previous exercise ./java/data into ./java/legos
  NOTE: for III above, this code came from "EXTRA PROMPTS TO TRY:" letter "G" in task 1 "DATA"

  1. in each of the three methods of PostgresDataAccess.java (logSensorData, fetchSensorData, purgeSensorData) create a connection to the postgres database, use the same/similar logic for connecting to a postgres database found in the PostgresData.java source file
  2. in the PostgresDataAccess.java's logSensorData, take the "String jsonData" being passed in to the logSensorData() method to populate the params of the insert, use the same/similar logic for inserting sensor data into a postgres database found in the PostgresData.java source file
  3. in the PostgresDataAccess.java's fetchSensorData, create a List<String> of JSON strings resulting from the select to a postgres table as the return for fetchSensorData(), use the same/similar logic for selecting sensor data from a postgres database found in the PostgresData.java source file
  4. in the PostgresDataAccess.java's purgeSensorData, delete/truncate all data in the sensor data table, use the same/similar logic for deleting/truncating sensor data from a postgres database found in the PostgresData.java source file
  5. Reuse the OneString helper from earlier tasks for generating, validating, and formatting data. Treat it as a simple utility that can be called directly from the application code.

  A. Using the public interface for SensorDataAccessProtocol, implement a method to instantiate a new sensor data access object based on an environment variable.
  B. Implement a better logging mechanism for the sensor data access object.


===============================================================================


TASK 1 - JAVA DATA (REDIS)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. Create a java method to connect to a redis database
  2. Create a java method that will store the following string into a redis database
  3. Create a java method that will retrieve the following string from a redis database
  4. Create a java method that will delete the following string from a redis database
  5. Create a main method that will call each of the methods
  6. Create a gradle.build file to include all requirements in this source file
  7. Modify all five methods into one source file using this string as the string that is being stored:

  A. Create a java method that will update any value in the key value pair of a mutable map
  B. Create a java method that will generate a random number between 22.4 and 34.1, limited to one decimal place of precision
  C. Create a java method that will generate the integer value of the current Unix Epoch Timestamp
  D. Create a java method that will update both the "recorded" value with the current Unix Epoch Timestamp, and the "value" with a random number between 22.4 and 34.1, using the following string as input:
  E. Modify the original code to pass-in/insert a randomized string into the redis database each time the code is run
  F. Create a java method that will remove any key/value pair from a map (like "id" or "_id")
  G. Combine all of the above to create a small helper file that works with the OneString JSON data (generate sample data, validate required fields, and convert JSON to CSV). This helper should be simple utility code and can be called directly.


TASK 2 - JAVA API (REDIS)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. create a very basic web app using the java language spring framework
  2. what would the gradle.build file look like for this Main.java file
  3. how do i modify the spring app to bind to any ip address and a specific port when it runs
  4. add routes for the following:
      GET /
      POST /echo
      POST /log
      GET /report
      POST or GET /purge
  A. return the exact same JSON object that is sent in on the HTTP POST request
  B. create a static string constant for the following JSON structure:
        { "recorded" : 1768570200, "location" : "den", "sensor" : "bmp280", "measurement" : "temperature", "units" : "C", "value" : 22.3 }
  C. create a method to convert a json string to a csv string, using the keys as the column names
  D. can you do this without using the crate csv
  E. return the csv string as a downloadable file, be sure to modify the headers of the response
  F. return string message as a JSON object
  G. use the WGET/CURL test script you created above to generate a postman file for importing the API endpoints


TASK 3 - JAVA ACCESS (REDIS)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. write a Java interface for sensor data access with three abstract methods: log, fetch, and purge, using JSON strings and type declarations.
  2. create a class that implements the sensor data access protocol interface for RedisDataAccess.java
  3. in a Main.java file, create an instance of the RedisDataAccess class and call the log, fetch, and purge methods
  4. what would the gradle.build file look like for this Main.java file


TASK 4 - JAVA LEGOS (REDIS)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  I. copy the entire api solution from the previous exercise ./java/api/spring-app into ./java/legos
  II. copy only the RedisDataAccess.java, SensorDataAccessProtocol.java from the previous exercise ./java/access into ./java/legos
  III. copy only the SensorDataHelper.java from the previous exercise ./java/data into ./java/legos
  NOTE: for III above, this code came from "EXTRA PROMPTS TO TRY:" letter "G" in task 1 "DATA"

  1. in each of the three methods of RedisDataAccess.java (logSensorData, fetchSensorData, purgeSensorData) create a connection to the redis database, use the same/similar logic for connecting to a redis database found in the RedisData.java source file
  2. in the RedisDataAccess.java's logSensorData, take the "String jsonData" being passed in to the logSensorData() method to populate the params of the insert, use the same/similar logic for inserting sensor data into a redis database found in the RedisData.java source file
  3. in the RedisDataAccess.java's fetchSensorData, create a List<String> of JSON strings resulting from the select to a redis list as the return for fetchSensorData(), use the same/similar logic for selecting sensor data from a redis database found in the RedisData.java source file
  4. in the RedisDataAccess.java's purgeSensorData, delete/truncate all data in the sensor data list, use the same/similar logic for deleting/truncating sensor data from a redis database found in the RedisData.java source file
  5. Reuse the OneString helper from earlier tasks for generating, validating, and formatting data. Treat it as a simple utility that can be called directly from the application code.

  A. Using the public interface for SensorDataAccessProtocol, implement a method to instantiate a new sensor data access object based on an environment variable.
  B. Implement a better logging mechanism for the sensor data access object.


===============================================================================
JAVA - SECOND FRAMEWORK (QUARKUS)
===============================================================================

TASK 2 - JAVA API (CASSANDRA) - QUARKUS
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. create a very basic web app using the java language quarkus framework
  2. what would the gradle.build file look like for this Main.java file
  3. how do i modify the quarkus app to bind to any ip address and a specific port when it runs
  4. add routes for the following:
      GET /
      POST /echo
      POST /log
      GET /report
      POST or GET /purge
  A. return the exact same JSON object that is sent in on the HTTP POST request
  B. create a static string constant for the following JSON structure:
        { "recorded" : 1768570200, "location" : "den", "sensor" : "bmp280", "measurement" : "temperature", "units" : "C", "value" : 22.3 }
  C. create a method to convert a json string to a csv string, using the keys as the column names
  D. can you do this without using the crate csv
  E. return the csv string as a downloadable file, be sure to modify the headers of the response
  F. return string message as a JSON object
  G. use the WGET/CURL test script you created above to generate a postman file for importing the API endpoints


TASK 2 - JAVA API (MYSQL) - QUARKUS
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. create a very basic web app using the java language quarkus framework
  2. what would the gradle.build file look like for this Main.java file
  3. how do i modify the quarkus app to bind to any ip address and a specific port when it runs
  4. add routes for the following:
      GET /
      POST /echo
      POST /log
      GET /report
      POST or GET /purge
  A. return the exact same JSON object that is sent in on the HTTP POST request
  B. create a static string constant for the following JSON structure:
        { "recorded" : 1768570200, "location" : "den", "sensor" : "bmp280", "measurement" : "temperature", "units" : "C", "value" : 22.3 }
  C. create a method to convert a json string to a csv string, using the keys as the column names
  D. can you do this without using the crate csv
  E. return the csv string as a downloadable file, be sure to modify the headers of the response
  F. return string message as a JSON object
  G. use the WGET/CURL test script you created above to generate a postman file for importing the API endpoints


TASK 2 - JAVA API (POSTGRES) - QUARKUS
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. create a very basic web app using the java language quarkus framework
  2. what would the gradle.build file look like for this Main.java file
  3. how do i modify the quarkus app to bind to any ip address and a specific port when it runs
  4. add routes for the following:
      GET /
      POST /echo
      POST /log
      GET /report
      POST or GET /purge
  A. return the exact same JSON object that is sent in on the HTTP POST request
  B. create a static string constant for the following JSON structure:
        { "recorded" : 1768570200, "location" : "den", "sensor" : "bmp280", "measurement" : "temperature", "units" : "C", "value" : 22.3 }
  C. create a method to convert a json string to a csv string, using the keys as the column names
  D. can you do this without using the crate csv
  E. return the csv string as a downloadable file, be sure to modify the headers of the response
  F. return string message as a JSON object
  G. use the WGET/CURL test script you created above to generate a postman file for importing the API endpoints


TASK 2 - JAVA API (REDIS) - QUARKUS
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. create a very basic web app using the java language quarkus framework
  2. what would the gradle.build file look like for this Main.java file
  3. how do i modify the quarkus app to bind to any ip address and a specific port when it runs
  4. add routes for the following:
      GET /
      POST /echo
      POST /log
      GET /report
      POST or GET /purge
  A. return the exact same JSON object that is sent in on the HTTP POST request
  B. create a static string constant for the following JSON structure:
        { "recorded" : 1768570200, "location" : "den", "sensor" : "bmp280", "measurement" : "temperature", "units" : "C", "value" : 22.3 }
  C. create a method to convert a json string to a csv string, using the keys as the column names
  D. can you do this without using the crate csv
  E. return the csv string as a downloadable file, be sure to modify the headers of the response
  F. return string message as a JSON object
  G. use the WGET/CURL test script you created above to generate a postman file for importing the API endpoints


TASK 4 - JAVA LEGOS (CASSANDRA) - QUARKUS
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  This second lego assignment assumes that you have already successfully implemented and tested the Legos assignment for this language once already:

  I. copy the entire api solution from the previous API exercise of the quarkus framework
  II. copy all of the data source files you modified in the first implementation of legos using the spring framework
  III. cut/paste the same dependency injection method from the first implementation of legos using the spring framework

  1. For each of the three methods of the quarkus framework create a connection to the appropriate public interface for each route (/log, /report, & /purge)
  2. Reuse the OneString helper from earlier tasks for generating, validating, and formatting data. Treat it as a simple utility that can be called directly from the application code.

  NOTE: this time the public interface method for each of the databases should already be implemented


TASK 4 - JAVA LEGOS (MYSQL) - QUARKUS
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  This second lego assignment assumes that you have already successfully implemented and tested the Legos assignment for this language once already:

  I. copy the entire api solution from the previous API exercise of the quarkus framework
  II. copy all of the data source files you modified in the first implementation of legos using the spring framework
  III. cut/paste the same dependency injection method from the first implementation of legos using the spring framework

  1. For each of the three methods of the quarkus framework create a connection to the appropriate public interface for each route (/log, /report, & /purge)
  2. Reuse the OneString helper from earlier tasks for generating, validating, and formatting data. Treat it as a simple utility that can be called directly from the application code.

  NOTE: this time the public interface method for each of the databases should already be implemented


TASK 4 - JAVA LEGOS (POSTGRES) - QUARKUS
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  This second lego assignment assumes that you have already successfully implemented and tested the Legos assignment for this language once already:

  I. copy the entire api solution from the previous API exercise of the quarkus framework
  II. copy all of the data source files you modified in the first implementation of legos using the spring framework
  III. cut/paste the same dependency injection method from the first implementation of legos using the spring framework

  1. For each of the three methods of the quarkus framework create a connection to the appropriate public interface for each route (/log, /report, & /purge)
  2. Reuse the OneString helper from earlier tasks for generating, validating, and formatting data. Treat it as a simple utility that can be called directly from the application code.

  NOTE: this time the public interface method for each of the databases should already be implemented


TASK 4 - JAVA LEGOS (REDIS) - QUARKUS
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  This second lego assignment assumes that you have already successfully implemented and tested the Legos assignment for this language once already:

  I. copy the entire api solution from the previous API exercise of the quarkus framework
  II. copy all of the data source files you modified in the first implementation of legos using the spring framework
  III. cut/paste the same dependency injection method from the first implementation of legos using the spring framework

  1. For each of the three methods of the quarkus framework create a connection to the appropriate public interface for each route (/log, /report, & /purge)
  2. Reuse the OneString helper from earlier tasks for generating, validating, and formatting data. Treat it as a simple utility that can be called directly from the application code.

  NOTE: this time the public interface method for each of the databases should already be implemented


===============================================================================


NOTES FOR ALL TASKS & DATABASES
+++

For each task, generate the appropriate gradle.build file for Java.

For each task, be sure to follow the Java naming conventions:
 Files - UpperCamelCase.java
 Classes, Interfaces - UpperCamelCase
 Methods, Variables - lowerCamelCase
 Constants - SCREAMING_SNAKE_CASE
 Packages - lowercase.dot.separated

For the Cassandra database, use the following schema for a table named "sensor_data" in a keyspace named "sensor_data_db":
  CREATE TABLE IF NOT EXISTS sensor_data (
   recorded bigint,
   location text,
   sensor text,
   measurement text,
   units text,
   value double,
   PRIMARY KEY (recorded, location, sensor)
  );

For the MySQL database, use the following schema for a table named "sensor_data" in a database named "sensor_data_db":
  CREATE TABLE IF NOT EXISTS sensor_data (
   recorded BIGINT NOT NULL,
   location VARCHAR(255) NOT NULL,
   sensor VARCHAR(255) NOT NULL,
   measurement VARCHAR(255) NOT NULL,
   units VARCHAR(10) NOT NULL,
   value DECIMAL(5,2) NOT NULL
  );

For the Postgres database, use the following schema for a table named "sensor_data" in a database named "sensor_data_db":
  CREATE TABLE IF NOT EXISTS sensor_data (
   recorded BIGINT NOT NULL,
   location VARCHAR(255) NOT NULL,
   sensor VARCHAR(255) NOT NULL,
   measurement VARCHAR(255) NOT NULL,
   units VARCHAR(255) NOT NULL,
   value NUMERIC(10, 2) NOT NULL
  );

For the Redis database, use the List data type by using rpush and lrange to store and retrieve for the key "sensor_data_db:sensor_data"

For Java's implementation of Dependency Injection to achieve Inversion of Control, use a public interface
