# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright (C) 2025-2026 ggeoffre, LLC
===============================================================================
SWIFT - ONLY FRAMEWORK (VAPOR)
===============================================================================

TASK 1 - SWIFT DATA (MONGO)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. Create a swift function to connect to a mongo database
  2. Create a swift function that will store the following string into a mongo database
  3. Create a swift function that will retrieve the following string from a mongo database
  4. Create a swift function that will delete the following string from a mongo database
  5. Create a main function that will call each of the functions
  6. Create a Package.swift file to include all requirements in this source file
  7. Modify all five functions into one source file using this string as the string that is being stored:

  A. Create a swift function that will update any value in the key value pair of a mutable dictionary
  B. Create a swift function that will generate a random number between 22.4 and 34.1, limited to one decimal place of precision
  C. Create a swift function that will generate the integer value of the current Unix Epoch Timestamp
  D. Create a swift function that will update both the "recorded" value with the current Unix Epoch Timestamp, and the "value" with a random number between 22.4 and 34.1, using the following string as input:
  E. Modify the original code to pass-in/insert a randomized string into the mongo database each time the code is run
  F. Create a swift function that will remove any key/value pair from a dictionary (like "id" or "_id")
  G. Combine all of the above to create a small helper file that works with the OneString JSON data (generate sample data, validate required fields, and convert JSON to CSV). This helper should be simple utility code and can be called directly.


TASK 2 - SWIFT API (MONGO)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. create a very basic web app using the swift language vapor framework
  2. what would the Package.swift file look like for this main.swift file
  3. how do i modify the vapor app to bind to any ip address and a specific port when it runs
  4. add routes for the following:
      GET /
      POST /echo
      POST /log
      GET /report
      POST or GET /purge
  A. return the exact same JSON object that is sent in on the HTTP POST request
  B. create a constant string for the following JSON structure:
        { "recorded" : 1768570200, "location" : "den", "sensor" : "bmp280", "measurement" : "temperature", "units" : "C", "value" : 22.3 }
  C. create a function to convert a json string to a csv string, using the keys as the column names
  D. can you do this without using the crate csv
  E. return the csv string as a downloadable file, be sure to modify the headers of the response
  F. return string message as a JSON object
  G. use the WGET/CURL test script you created above to generate a postman file for importing the API endpoints


TASK 3 - SWIFT ACCESS (MONGO)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. write a Swift protocol for sensor data access with three methods: log, fetch, and purge, using JSON strings and type annotations.
  2. create a class that implements the sensor data access protocol for MongoDataAccess.swift
  3. in a Main.swift file, create an instance of the MongoDataAccess class and call the log, fetch, and purge methods
  4. what would the Package.swift file look like for this Main.swift file


TASK 4 - SWIFT LEGOS (MONGO)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  I. copy the entire api solution from the previous exercise ./swift/api/vapor-app into ./swift/legos
  II. copy only the MongoDataAccess.swift, SensorDataAccessProtocol.swift from the previous exercise ./swift/access into ./swift/legos
  III. copy only the SensorDataHelper.swift from the previous exercise ./swift/data into ./swift/legos
  NOTE: for III above, this code came from "EXTRA PROMPTS TO TRY:" letter "G" in task 1 "DATA"

  1. in each of the three methods of MongoDataAccess.swift (logSensorData, fetchSensorData, purgeSensorData) create a connection to the mongo database, use the same/similar logic for connecting to a mongo database found in the MongoData.swift source file
  2. in the MongoDataAccess.swift's logSensorData, take the "jsonData: String" being passed in to the logSensorData() method to populate the params of the insert, use the same/similar logic for inserting sensor data into a mongo database found in the MongoData.swift source file
  3. in the MongoDataAccess.swift's fetchSensorData, create a [String] of JSON strings resulting from the select to a mongo collection as the return for fetchSensorData(), use the same/similar logic for selecting sensor data from a mongo database found in the MongoData.swift source file
  4. in the MongoDataAccess.swift's purgeSensorData, delete/truncate all data in the sensor data collection, use the same/similar logic for deleting/truncating sensor data from a mongo database found in the MongoData.swift source file
  5. Reuse the OneString helper from earlier tasks for generating, validating, and formatting data. Treat it as a simple utility that can be called directly from the application code.

  A. Using the public protocol for SensorDataAccessProtocol, implement a function to instantiate a new sensor data access object based on an environment variable.
  B. Implement a better logging mechanism for the sensor data access object.


TASK 1 - SWIFT DATA (CASSANDRA)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. Create a swift function to connect to a cassandra database
  2. Create a swift function that will store the following string into a cassandra database
  3. Create a swift function that will retrieve the following string from a cassandra database
  4. Create a swift function that will delete the following string from a cassandra database
  5. Create a main function that will call each of the functions
  6. Create a Package.swift file to include all requirements in this source file
  7. Modify all five functions into one source file using this string as the string that is being stored:

  A. Create a swift function that will update any value in the key value pair of a mutable dictionary
  B. Create a swift function that will generate a random number between 22.4 and 34.1, limited to one decimal place of precision
  C. Create a swift function that will generate the integer value of the current Unix Epoch Timestamp
  D. Create a swift function that will update both the "recorded" value with the current Unix Epoch Timestamp, and the "value" with a random number between 22.4 and 34.1, using the following string as input:
  E. Modify the original code to pass-in/insert a randomized string into the cassandra database each time the code is run
  F. Create a swift function that will remove any key/value pair from a dictionary (like "id" or "_id")
  G. Combine all of the above to create a small helper file that works with the OneString JSON data (generate sample data, validate required fields, and convert JSON to CSV). This helper should be simple utility code and can be called directly.


TASK 2 - SWIFT API (CASSANDRA)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. create a very basic web app using the swift language vapor framework
  2. what would the Package.swift file look like for this main.swift file
  3. how do i modify the vapor app to bind to any ip address and a specific port when it runs
  4. add routes for the following:
      GET /
      POST /echo
      POST /log
      GET /report
      POST or GET /purge
  A. return the exact same JSON object that is sent in on the HTTP POST request
  B. create a constant string for the following JSON structure:
        { "recorded" : 1768570200, "location" : "den", "sensor" : "bmp280", "measurement" : "temperature", "units" : "C", "value" : 22.3 }
  C. create a function to convert a json string to a csv string, using the keys as the column names
  D. can you do this without using the crate csv
  E. return the csv string as a downloadable file, be sure to modify the headers of the response
  F. return string message as a JSON object
  G. use the WGET/CURL test script you created above to generate a postman file for importing the API endpoints


TASK 3 - SWIFT ACCESS (CASSANDRA)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. write a Swift protocol for sensor data access with three methods: log, fetch, and purge, using JSON strings and type annotations.
  2. create a class that implements the sensor data access protocol for CassandraDataAccess.swift
  3. in a Main.swift file, create an instance of the CassandraDataAccess class and call the log, fetch, and purge methods
  4. what would the Package.swift file look like for this Main.swift file


TASK 4 - SWIFT LEGOS (CASSANDRA)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  I. copy the entire api solution from the previous exercise ./swift/api/vapor-app into ./swift/legos
  II. copy only the CassandraDataAccess.swift, SensorDataAccessProtocol.swift from the previous exercise ./swift/access into ./swift/legos
  III. copy only the SensorDataHelper.swift from the previous exercise ./swift/data into ./swift/legos
  NOTE: for III above, this code came from "EXTRA PROMPTS TO TRY:" letter "G" in task 1 "DATA"

  1. in each of the three methods of CassandraDataAccess.swift (logSensorData, fetchSensorData, purgeSensorData) create a connection to the cassandra database, use the same/similar logic for connecting to a cassandra database found in the CassandraData.swift source file
  2. in the CassandraDataAccess.swift's logSensorData, take the "jsonData: String" being passed in to the logSensorData() method to populate the params of the insert, use the same/similar logic for inserting sensor data into a cassandra database found in the CassandraData.swift source file
  3. in the CassandraDataAccess.swift's fetchSensorData, create a [String] of JSON strings resulting from the select to a cassandra table as the return for fetchSensorData(), use the same/similar logic for selecting sensor data from a cassandra database found in the CassandraData.swift source file
  4. in the CassandraDataAccess.swift's purgeSensorData, delete/truncate all data in the sensor data table, use the same/similar logic for deleting/truncating sensor data from a cassandra database found in the CassandraData.swift source file
  5. Reuse the OneString helper from earlier tasks for generating, validating, and formatting data. Treat it as a simple utility that can be called directly from the application code.

  A. Using the public protocol for SensorDataAccessProtocol, implement a function to instantiate a new sensor data access object based on an environment variable.
  B. Implement a better logging mechanism for the sensor data access object.


===============================================================================


TASK 1 - SWIFT DATA (MYSQL)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. Create a swift function to connect to a mysql database
  2. Create a swift function that will store the following string into a mysql database
  3. Create a swift function that will retrieve the following string from a mysql database
  4. Create a swift function that will delete the following string from a mysql database
  5. Create a main function that will call each of the functions
  6. Create a Package.swift file to include all requirements in this source file
  7. Modify all five functions into one source file using this string as the string that is being stored:

  A. Create a swift function that will update any value in the key value pair of a mutable dictionary
  B. Create a swift function that will generate a random number between 22.4 and 34.1, limited to one decimal place of precision
  C. Create a swift function that will generate the integer value of the current Unix Epoch Timestamp
  D. Create a swift function that will update both the "recorded" value with the current Unix Epoch Timestamp, and the "value" with a random number between 22.4 and 34.1, using the following string as input:
  E. Modify the original code to pass-in/insert a randomized string into the mysql database each time the code is run
  F. Create a swift function that will remove any key/value pair from a dictionary (like "id" or "_id")
  G. Combine all of the above to create a small helper file that works with the OneString JSON data (generate sample data, validate required fields, and convert JSON to CSV). This helper should be simple utility code and can be called directly.


TASK 2 - SWIFT API (MYSQL)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. create a very basic web app using the swift language vapor framework
  2. what would the Package.swift file look like for this main.swift file
  3. how do i modify the vapor app to bind to any ip address and a specific port when it runs
  4. add routes for the following:
      GET /
      POST /echo
      POST /log
      GET /report
      POST or GET /purge
  A. return the exact same JSON object that is sent in on the HTTP POST request
  B. create a constant string for the following JSON structure:
        { "recorded" : 1768570200, "location" : "den", "sensor" : "bmp280", "measurement" : "temperature", "units" : "C", "value" : 22.3 }
  C. create a function to convert a json string to a csv string, using the keys as the column names
  D. can you do this without using the crate csv
  E. return the csv string as a downloadable file, be sure to modify the headers of the response
  F. return string message as a JSON object
  G. use the WGET/CURL test script you created above to generate a postman file for importing the API endpoints


TASK 3 - SWIFT ACCESS (MYSQL)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. write a Swift protocol for sensor data access with three methods: log, fetch, and purge, using JSON strings and type annotations.
  2. create a class that implements the sensor data access protocol for MysqlDataAccess.swift
  3. in a Main.swift file, create an instance of the MysqlDataAccess class and call the log, fetch, and purge methods
  4. what would the Package.swift file look like for this Main.swift file


TASK 4 - SWIFT LEGOS (MYSQL)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  I. copy the entire api solution from the previous exercise ./swift/api/vapor-app into ./swift/legos
  II. copy only the MysqlDataAccess.swift, SensorDataAccessProtocol.swift from the previous exercise ./swift/access into ./swift/legos
  III. copy only the SensorDataHelper.swift from the previous exercise ./swift/data into ./swift/legos
  NOTE: for III above, this code came from "EXTRA PROMPTS TO TRY:" letter "G" in task 1 "DATA"

  1. in each of the three methods of MysqlDataAccess.swift (logSensorData, fetchSensorData, purgeSensorData) create a connection to the mysql database, use the same/similar logic for connecting to a mysql database found in the MysqlData.swift source file
  2. in the MysqlDataAccess.swift's logSensorData, take the "jsonData: String" being passed in to the logSensorData() method to populate the params of the insert, use the same/similar logic for inserting sensor data into a mysql database found in the MysqlData.swift source file
  3. in the MysqlDataAccess.swift's fetchSensorData, create a [String] of JSON strings resulting from the select to a mysql table as the return for fetchSensorData(), use the same/similar logic for selecting sensor data from a mysql database found in the MysqlData.swift source file
  4. in the MysqlDataAccess.swift's purgeSensorData, delete/truncate all data in the sensor data table, use the same/similar logic for deleting/truncating sensor data from a mysql database found in the MysqlData.swift source file
  5. Reuse the OneString helper from earlier tasks for generating, validating, and formatting data. Treat it as a simple utility that can be called directly from the application code.

  A. Using the public protocol for SensorDataAccessProtocol, implement a function to instantiate a new sensor data access object based on an environment variable.
  B. Implement a better logging mechanism for the sensor data access object.


===============================================================================


TASK 1 - SWIFT DATA (POSTGRES)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. Create a swift function to connect to a postgres database
  2. Create a swift function that will store the following string into a postgres database
  3. Create a swift function that will retrieve the following string from a postgres database
  4. Create a swift function that will delete the following string from a postgres database
  5. Create a main function that will call each of the functions
  6. Create a Package.swift file to include all requirements in this source file
  7. Modify all five functions into one source file using this string as the string that is being stored:

  A. Create a swift function that will update any value in the key value pair of a mutable dictionary
  B. Create a swift function that will generate a random number between 22.4 and 34.1, limited to one decimal place of precision
  C. Create a swift function that will generate the integer value of the current Unix Epoch Timestamp
  D. Create a swift function that will update both the "recorded" value with the current Unix Epoch Timestamp, and the "value" with a random number between 22.4 and 34.1, using the following string as input:
  E. Modify the original code to pass-in/insert a randomized string into the postgres database each time the code is run
  F. Create a swift function that will remove any key/value pair from a dictionary (like "id" or "_id")
  G. Combine all of the above to create a small helper file that works with the OneString JSON data (generate sample data, validate required fields, and convert JSON to CSV). This helper should be simple utility code and can be called directly.


TASK 2 - SWIFT API (POSTGRES)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. create a very basic web app using the swift language vapor framework
  2. what would the Package.swift file look like for this main.swift file
  3. how do i modify the vapor app to bind to any ip address and a specific port when it runs
  4. add routes for the following:
      GET /
      POST /echo
      POST /log
      GET /report
      POST or GET /purge
  A. return the exact same JSON object that is sent in on the HTTP POST request
  B. create a constant string for the following JSON structure:
        { "recorded" : 1768570200, "location" : "den", "sensor" : "bmp280", "measurement" : "temperature", "units" : "C", "value" : 22.3 }
  C. create a function to convert a json string to a csv string, using the keys as the column names
  D. can you do this without using the crate csv
  E. return the csv string as a downloadable file, be sure to modify the headers of the response
  F. return string message as a JSON object
  G. use the WGET/CURL test script you created above to generate a postman file for importing the API endpoints


TASK 3 - SWIFT ACCESS (POSTGRES)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. write a Swift protocol for sensor data access with three methods: log, fetch, and purge, using JSON strings and type annotations.
  2. create a class that implements the sensor data access protocol for PostgresDataAccess.swift
  3. in a Main.swift file, create an instance of the PostgresDataAccess class and call the log, fetch, and purge methods
  4. what would the Package.swift file look like for this Main.swift file


TASK 4 - SWIFT LEGOS (POSTGRES)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  I. copy the entire api solution from the previous exercise ./swift/api/vapor-app into ./swift/legos
  II. copy only the PostgresDataAccess.swift, SensorDataAccessProtocol.swift from the previous exercise ./swift/access into ./swift/legos
  III. copy only the SensorDataHelper.swift from the previous exercise ./swift/data into ./swift/legos
  NOTE: for III above, this code came from "EXTRA PROMPTS TO TRY:" letter "G" in task 1 "DATA"

  1. in each of the three methods of PostgresDataAccess.swift (logSensorData, fetchSensorData, purgeSensorData) create a connection to the postgres database, use the same/similar logic for connecting to a postgres database found in the PostgresData.swift source file
  2. in the PostgresDataAccess.swift's logSensorData, take the "jsonData: String" being passed in to the logSensorData() method to populate the params of the insert, use the same/similar logic for inserting sensor data into a postgres database found in the PostgresData.swift source file
  3. in the PostgresDataAccess.swift's fetchSensorData, create a [String] of JSON strings resulting from the select to a postgres table as the return for fetchSensorData(), use the same/similar logic for selecting sensor data from a postgres database found in the PostgresData.swift source file
  4. in the PostgresDataAccess.swift's purgeSensorData, delete/truncate all data in the sensor data table, use the same/similar logic for deleting/truncating sensor data from a postgres database found in the PostgresData.swift source file
  5. Reuse the OneString helper from earlier tasks for generating, validating, and formatting data. Treat it as a simple utility that can be called directly from the application code.

  A. Using the public protocol for SensorDataAccessProtocol, implement a function to instantiate a new sensor data access object based on an environment variable.
  B. Implement a better logging mechanism for the sensor data access object.


===============================================================================


TASK 1 - SWIFT DATA (REDIS)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. Create a swift function to connect to a redis database
  2. Create a swift function that will store the following string into a redis database
  3. Create a swift function that will retrieve the following string from a redis database
  4. Create a swift function that will delete the following string from a redis database
  5. Create a main function that will call each of the functions
  6. Create a Package.swift file to include all requirements in this source file
  7. Modify all five functions into one source file using this string as the string that is being stored:

  A. Create a swift function that will update any value in the key value pair of a mutable dictionary
  B. Create a swift function that will generate a random number between 22.4 and 34.1, limited to one decimal place of precision
  C. Create a swift function that will generate the integer value of the current Unix Epoch Timestamp
  D. Create a swift function that will update both the "recorded" value with the current Unix Epoch Timestamp, and the "value" with a random number between 22.4 and 34.1, using the following string as input:
  E. Modify the original code to pass-in/insert a randomized string into the redis database each time the code is run
  F. Create a swift function that will remove any key/value pair from a dictionary (like "id" or "_id")
  G. Combine all of the above to create a small helper file that works with the OneString JSON data (generate sample data, validate required fields, and convert JSON to CSV). This helper should be simple utility code and can be called directly.


TASK 2 - SWIFT API (REDIS)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. create a very basic web app using the swift language vapor framework
  2. what would the Package.swift file look like for this main.swift file
  3. how do i modify the vapor app to bind to any ip address and a specific port when it runs
  4. add routes for the following:
      GET /
      POST /echo
      POST /log
      GET /report
      POST or GET /purge
  A. return the exact same JSON object that is sent in on the HTTP POST request
  B. create a constant string for the following JSON structure:
        { "recorded" : 1768570200, "location" : "den", "sensor" : "bmp280", "measurement" : "temperature", "units" : "C", "value" : 22.3 }
  C. create a function to convert a json string to a csv string, using the keys as the column names
  D. can you do this without using the crate csv
  E. return the csv string as a downloadable file, be sure to modify the headers of the response
  F. return string message as a JSON object
  G. use the WGET/CURL test script you created above to generate a postman file for importing the API endpoints


TASK 3 - SWIFT ACCESS (REDIS)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  1. write a Swift protocol for sensor data access with three methods: log, fetch, and purge, using JSON strings and type annotations.
  2. create a class that implements the sensor data access protocol for RedisDataAccess.swift
  3. in a Main.swift file, create an instance of the RedisDataAccess class and call the log, fetch, and purge methods
  4. what would the Package.swift file look like for this Main.swift file


TASK 4 - SWIFT LEGOS (REDIS)
+++

  The String: {"recorded": 1768570200,"location": "den","sensor": "bmp280","measurement": "temperature","units": "C","value": 22.3}

  I. copy the entire api solution from the previous exercise ./swift/api/vapor-app into ./swift/legos
  II. copy only the RedisDataAccess.swift, SensorDataAccessProtocol.swift from the previous exercise ./swift/access into ./swift/legos
  III. copy only the SensorDataHelper.swift from the previous exercise ./swift/data into ./swift/legos
  NOTE: for III above, this code came from "EXTRA PROMPTS TO TRY:" letter "G" in task 1 "DATA"

  1. in each of the three methods of RedisDataAccess.swift (logSensorData, fetchSensorData, purgeSensorData) create a connection to the redis database, use the same/similar logic for connecting to a redis database found in the RedisData.swift source file
  2. in the RedisDataAccess.swift's logSensorData, take the "jsonData: String" being passed in to the logSensorData() method to populate the params of the insert, use the same/similar logic for inserting sensor data into a redis database found in the RedisData.swift source file
  3. in the RedisDataAccess.swift's fetchSensorData, create a [String] of JSON strings resulting from the select to a redis list as the return for fetchSensorData(), use the same/similar logic for selecting sensor data from a redis database found in the RedisData.swift source file
  4. in the RedisDataAccess.swift's purgeSensorData, delete/truncate all data in the sensor data list, use the same/similar logic for deleting/truncating sensor data from a redis database found in the RedisData.swift source file
  5. Reuse the OneString helper from earlier tasks for generating, validating, and formatting data. Treat it as a simple utility that can be called directly from the application code.

  A. Using the public protocol for SensorDataAccessProtocol, implement a function to instantiate a new sensor data access object based on an environment variable.
  B. Implement a better logging mechanism for the sensor data access object.


===============================================================================


NOTES FOR ALL TASKS & DATABASES
+++

For each task, generate the appropriate Package.swift file for Swift.

For each task, be sure to follow the Swift naming conventions:
 Files - UpperCamelCase
 Classes, Structs, Enums, Protocols - UpperCamelCase.
 Functions, Methods, Variables - lowerCamelCase.
 Constants - lowerCamelCase.

For the Cassandra database, use the following schema for a table named "sensor_data" in a keyspace named "sensor_data_db":
  CREATE TABLE IF NOT EXISTS sensor_data (
   recorded bigint,
   location text,
   sensor text,
   measurement text,
   units text,
   value double,
   PRIMARY KEY (recorded, location, sensor)
  );

For the MySQL database, use the following schema for a table named "sensor_data" in a database named "sensor_data_db":
  CREATE TABLE IF NOT EXISTS sensor_data (
   recorded BIGINT NOT NULL,
   location VARCHAR(255) NOT NULL,
   sensor VARCHAR(255) NOT NULL,
   measurement VARCHAR(255) NOT NULL,
   units VARCHAR(10) NOT NULL,
   value DECIMAL(5,2) NOT NULL
  );

For the Postgres database, use the following schema for a table named "sensor_data" in a database named "sensor_data_db":
  CREATE TABLE IF NOT EXISTS sensor_data (
   recorded BIGINT NOT NULL,
   location VARCHAR(255) NOT NULL,
   sensor VARCHAR(255) NOT NULL,
   measurement VARCHAR(255) NOT NULL,
   units VARCHAR(255) NOT NULL,
   value NUMERIC(10, 2) NOT NULL
  );

For the Redis database, use the List data type by using rpush and lrange to store and retrieve for the key "sensor_data_db:sensor_data"

For Swift's implementation of Dependency Injection to achieve Inversion of Control, use a public protocol
